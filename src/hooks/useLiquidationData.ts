
import { useState, useEffect } from 'react';
import { LiquidationBubble, getMarketCapCategory, LiquidationStats } from '../types/liquidation';
import { safeCreateDate, formatAmount, detectLiquidations } from '../utils/liquidationUtils';
import { useRealFlowData } from './useRealFlowData';
import { useSupabaseStorage } from './useSupabaseStorage';
import { usePersistedData } from './usePersistedData';

// Interface para callback de dados 24h
interface Use24hLiquidationCallback {
  addLiquidationToDaily: (liquidation: LiquidationBubble) => void;
}

export const useLiquidationData = (dailyCallback?: Use24hLiquidationCallback) => {
  const { flowData } = useRealFlowData();
  const { saveLiquidation } = useSupabaseStorage();
  
  // Usar dados persistidos
  const { 
    data: persistedLongLiquidations, 
    addData: addLongLiquidations 
  } = usePersistedData<LiquidationBubble>({
    key: 'liquidations_long',
    maxAgeMinutes: 5
  });
  
  const { 
    data: persistedShortLiquidations, 
    addData: addShortLiquidations 
  } = usePersistedData<LiquidationBubble>({
    key: 'liquidations_short',
    maxAgeMinutes: 5
  });

  const [longLiquidations, setLongLiquidations] = useState<LiquidationBubble[]>([]);
  const [shortLiquidations, setShortLiquidations] = useState<LiquidationBubble[]>([]);
  const [processedTickers, setProcessedTickers] = useState<Set<string>>(new Set());
  const [stats, setStats] = useState<LiquidationStats>({
    totalLong: 0,
    totalShort: 0,
    highCapLong: 0,
    highCapShort: 0,
    lowCapLong: 0,
    lowCapShort: 0
  });

  // Inicializar com dados persistidos
  useEffect(() => {
    console.log(`üìä Inicializando liquida√ß√µes com dados persistidos:`);
    console.log(`- Long liquidations: ${persistedLongLiquidations.length}`);
    console.log(`- Short liquidations: ${persistedShortLiquidations.length}`);
    
    setLongLiquidations(persistedLongLiquidations);
    setShortLiquidations(persistedShortLiquidations);
  }, [persistedLongLiquidations, persistedShortLiquidations]);

  // Limpeza autom√°tica a cada minuto
  useEffect(() => {
    const cleanupInterval = setInterval(() => {
      const now = new Date();
      const fifteenMinutesAgo = new Date(now.getTime() - 15 * 60 * 1000);

      console.log('üßπ Limpando liquida√ß√µes antigas...');
      
      setLongLiquidations(prev => {
        const filtered = prev.filter(liq => liq.lastUpdateTime > fifteenMinutesAgo);
        const removed = prev.length - filtered.length;
        if (removed > 0) {
          console.log(`üóëÔ∏è Removidas ${removed} liquida√ß√µes LONG antigas`);
        }
        return filtered;
      });
      
      setShortLiquidations(prev => {
        const filtered = prev.filter(liq => liq.lastUpdateTime > fifteenMinutesAgo);
        const removed = prev.length - filtered.length;
        if (removed > 0) {
          console.log(`üóëÔ∏è Removidas ${removed} liquida√ß√µes SHORT antigas`);
        }
        return filtered;
      });

      setProcessedTickers(new Set());
    }, 60000);

    return () => clearInterval(cleanupInterval);
  }, []);

  // NOVA FUN√á√ÉO: Calcular relev√¢ncia atual (baseada em activity atual, n√£o acumulada)
  const calculateCurrentRelevance = (liquidation: LiquidationBubble): number => {
    const now = new Date();
    const ageMinutes = (now.getTime() - liquidation.lastUpdateTime.getTime()) / (1000 * 60);
    
    // Decay temporal - liquida√ß√µes mais recentes t√™m mais relev√¢ncia
    const timeDecay = Math.max(0, 1 - (ageMinutes / 15)); // Decay total em 15 minutos
    
    // Score baseado em intensidade atual + volume atual + rec√™ncia
    const intensityScore = liquidation.intensity * 20; // 0-100
    const volumeScore = Math.min(liquidation.amount / 100000, 10) * 10; // At√© 100
    const recencyScore = timeDecay * 50; // At√© 50
    
    return intensityScore + volumeScore + recencyScore;
  };

  // NOVA FUN√á√ÉO: Filtrar por relev√¢ncia atual em vez de total acumulado
  const filterByCurrentRelevance = (liquidations: LiquidationBubble[]): LiquidationBubble[] => {
    // Calcular relev√¢ncia e ordenar
    const withRelevance = liquidations.map(liq => ({
      ...liq,
      currentRelevance: calculateCurrentRelevance(liq)
    }));
    
    // Ordenar por: 1. Relev√¢ncia atual, 2. Intensidade, 3. Rec√™ncia
    withRelevance.sort((a, b) => {
      if (b.currentRelevance !== a.currentRelevance) {
        return b.currentRelevance - a.currentRelevance;
      }
      if (b.intensity !== a.intensity) {
        return b.intensity - a.intensity;
      }
      return b.lastUpdateTime.getTime() - a.lastUpdateTime.getTime();
    });
    
    // Balanceamento: garantir mix entre high/low cap
    const highCap = withRelevance.filter(liq => liq.marketCap === 'high').slice(0, 25);
    const lowCap = withRelevance.filter(liq => liq.marketCap === 'low').slice(0, 25);
    
    const balanced = [...highCap, ...lowCap];
    
    // Re-ordenar o mix balanceado por relev√¢ncia
    balanced.sort((a, b) => b.currentRelevance - a.currentRelevance);
    
    console.log(`üîç Filtro de relev√¢ncia aplicado: ${liquidations.length} -> ${balanced.slice(0, 50).length}`);
    console.log(`üìä Balance: ${highCap.length} high cap, ${lowCap.length} low cap`);
    
    return balanced.slice(0, 50);
  };

  // Calcular estat√≠sticas
  const updateStats = (longs: LiquidationBubble[], shorts: LiquidationBubble[]) => {
    const newStats: LiquidationStats = {
      totalLong: longs.length,
      totalShort: shorts.length,
      highCapLong: longs.filter(l => l.marketCap === 'high').length,
      highCapShort: shorts.filter(l => l.marketCap === 'high').length,
      lowCapLong: longs.filter(l => l.marketCap === 'low').length,
      lowCapShort: shorts.filter(l => l.marketCap === 'low').length
    };
    
    setStats(newStats);
    
    // Log estat√≠sticas detalhadas
    console.log(`üìà STATS LIQUIDA√á√ïES:`, newStats);
    if (newStats.highCapLong === 0 || newStats.highCapShort === 0) {
      console.warn('‚ö†Ô∏è DESEQUIL√çBRIO: Faltam liquida√ß√µes HIGH CAP em algum tipo');
    }
    if (newStats.lowCapLong === 0 || newStats.lowCapShort === 0) {
      console.warn('‚ö†Ô∏è DESEQUIL√çBRIO: Faltam liquida√ß√µes LOW CAP em algum tipo');
    }
  };

  useEffect(() => {
    if (!flowData || flowData.length === 0) return;

    const now = new Date();
    const newLongLiquidations: LiquidationBubble[] = [];
    const newShortLiquidations: LiquidationBubble[] = [];

    // Processar apenas dados √∫nicos e v√°lidos
    const uniqueData = flowData.filter((data, index, self) => {
      const key = `${data.ticker}-${data.timestamp}`;
      return (
        data.ticker && 
        !isNaN(data.price) && 
        data.price > 0 &&
        !isNaN(data.volume) && 
        data.volume > 0 &&
        data.change_24h !== undefined &&
        !processedTickers.has(key) &&
        index === self.findIndex(d => d.ticker === data.ticker)
      );
    });

    console.log(`üîç Processando ${uniqueData.length} ativos √∫nicos para liquida√ß√µes...`);

    uniqueData.forEach(data => {
      try {
        const priceChange = data.change_24h || 0;
        const volumeValue = data.volume * data.price;
        const marketCap = getMarketCapCategory(data.ticker);
        const isHighMarketCap = marketCap === 'high';
        
        // NOVA L√ìGICA: Detec√ß√£o espelhada usando fun√ß√µes espec√≠ficas
        const detection = detectLiquidations(data.ticker, volumeValue, priceChange, isHighMarketCap);
        
        // Processar Long Liquidation se detectada
        if (detection.longLiquidation) {
          const liquidation: LiquidationBubble = {
            id: `${data.ticker}-long-${now.getTime()}`,
            asset: data.ticker.replace('USDT', ''),
            type: 'long',
            amount: volumeValue, // MANTIDO: amount = liquida√ß√£o atual
            price: data.price,
            marketCap,
            timestamp: safeCreateDate(data.timestamp),
            intensity: detection.longLiquidation.intensity,
            change24h: priceChange,
            volume: data.volume,
            lastUpdateTime: now,
            totalLiquidated: volumeValue // MANTIDO: para compatibilidade com componentes existentes
          };
          
          console.log(`üî¥ LONG LIQUIDATION: ${liquidation.asset} (${marketCap.toUpperCase()}) - Fall: ${priceChange.toFixed(2)}% - ${formatAmount(liquidation.amount)}`);
          
          // Salvar no Supabase
          saveLiquidation({
            asset: liquidation.asset,
            ticker: data.ticker,
            type: liquidation.type,
            amount: liquidation.amount,
            price: liquidation.price,
            market_cap: liquidation.marketCap,
            intensity: liquidation.intensity,
            change_24h: liquidation.change24h,
            volume: liquidation.volume,
            total_liquidated: liquidation.totalLiquidated,
            volume_spike: 1
          });
          
          // Adicionar aos totais 24h se callback dispon√≠vel
          if (dailyCallback?.addLiquidationToDaily) {
            dailyCallback.addLiquidationToDaily(liquidation);
          }
          
          newLongLiquidations.push(liquidation);
        }
        
        // Processar Short Liquidation se detectada
        if (detection.shortLiquidation) {
          const liquidation: LiquidationBubble = {
            id: `${data.ticker}-short-${now.getTime()}`,
            asset: data.ticker.replace('USDT', ''),
            type: 'short',
            amount: volumeValue, // MANTIDO: amount = liquida√ß√£o atual
            price: data.price,
            marketCap,
            timestamp: safeCreateDate(data.timestamp),
            intensity: detection.shortLiquidation.intensity,
            change24h: priceChange,
            volume: data.volume,
            lastUpdateTime: now,
            totalLiquidated: volumeValue // MANTIDO: para compatibilidade com componentes existentes
          };
          
          console.log(`üü¢ SHORT LIQUIDATION: ${liquidation.asset} (${marketCap.toUpperCase()}) - Rise: ${priceChange.toFixed(2)}% - ${formatAmount(liquidation.amount)}`);
          
          // Salvar no Supabase
          saveLiquidation({
            asset: liquidation.asset,
            ticker: data.ticker,
            type: liquidation.type,
            amount: liquidation.amount,
            price: liquidation.price,
            market_cap: liquidation.marketCap,
            intensity: liquidation.intensity,
            change_24h: liquidation.change24h,
            volume: liquidation.volume,
            total_liquidated: liquidation.totalLiquidated,
            volume_spike: 1
          });
          
          // Adicionar aos totais 24h se callback dispon√≠vel
          if (dailyCallback?.addLiquidationToDaily) {
            dailyCallback.addLiquidationToDaily(liquidation);
          }
          
          newShortLiquidations.push(liquidation);
        }

        // Marcar como processado se alguma liquida√ß√£o foi detectada
        if (detection.longLiquidation || detection.shortLiquidation) {
          setProcessedTickers(prev => new Set([...prev, `${data.ticker}-${data.timestamp}`]));
        }
      } catch (error) {
        console.error('Erro ao processar dados de liquida√ß√£o:', error, data);
      }
    });

    // Atualizar liquida√ß√µes com NOVO SISTEMA DE FILTRO por relev√¢ncia atual
    if (newLongLiquidations.length > 0) {
      setLongLiquidations(prev => {
        const updated = [...prev];
        
        newLongLiquidations.forEach(newLiq => {
          const existingIndex = updated.findIndex(liq => liq.asset === newLiq.asset);
          if (existingIndex >= 0) {
            // MUDAN√áA: N√£o acumular mais no amount - manter amount atual
            updated[existingIndex] = { 
              ...newLiq, // Substituir completamente com dados atuais
              lastUpdateTime: now
            };
          } else {
            updated.push(newLiq);
          }
        });
        
        // NOVO FILTRO: Usar relev√¢ncia atual em vez de totalLiquidated
        const filtered = filterByCurrentRelevance(updated);
        addLongLiquidations(newLongLiquidations);
        
        return filtered;
      });
    }
    
    if (newShortLiquidations.length > 0) {
      setShortLiquidations(prev => {
        const updated = [...prev];
        
        newShortLiquidations.forEach(newLiq => {
          const existingIndex = updated.findIndex(liq => liq.asset === newLiq.asset);
          if (existingIndex >= 0) {
            // MUDAN√áA: N√£o acumular mais no amount - manter amount atual
            updated[existingIndex] = { 
              ...newLiq, // Substituir completamente com dados atuais
              lastUpdateTime: now
            };
          } else {
            updated.push(newLiq);
          }
        });
        
        // NOVO FILTRO: Usar relev√¢ncia atual em vez de totalLiquidated
        const filtered = filterByCurrentRelevance(updated);
        addShortLiquidations(newShortLiquidations);
        
        return filtered;
      });
    }
  }, [flowData, processedTickers, saveLiquidation, addLongLiquidations, addShortLiquidations, dailyCallback]);

  // Atualizar stats quando liquida√ß√µes mudarem
  useEffect(() => {
    updateStats(longLiquidations, shortLiquidations);
  }, [longLiquidations, shortLiquidations]);

  return {
    longLiquidations,
    shortLiquidations,
    stats
  };
};
